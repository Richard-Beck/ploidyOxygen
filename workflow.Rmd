---
title: "testing"
output: html_document
date: "2025-08-18"
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "C:/Users/4473331/Documents/projects/021_ltee_models/ploidyOxygen/")
```

```{r}
source("code/db_utils.R")
source("code/plot_utils.R")
```

```{r}
  require(DBI)
  require(RMariaDB)
  dbvars <- load_db_vars("db_creds.txt")
  db <- dbConnect(
    MariaDB(),
    host = dbvars["HOST"],
    user = dbvars["USER"],
    password = dbvars["PASSWORD"],
    dbname = dbvars["DBNAME"]
  )

x <- dbGetQuery(db, "SELECT * FROM Passaging")
m <- dbGetQuery(db, "SELECT * FROM Media")
```


```{r}
cloneIds <- c("SUM159_NLS_2N_O1_A7K_harvest", "SUM159_NLS_2N_O2_A7K_harvest", "SUM-159_NLS_2N_A7M_K_harvest",
                "SUM-159_NLS_4N_O2_A17_seedT1", "SUM159_NLS_4N_O2_A7K_harvest", "SUM159_NLS_4N_O1_A7K_harvest",
                "SUM-159_NLS_4N_A5M_K_harvest", "SUM-159_NLS_4N_O1_A17_seedT1", "SUM-159_NLS_2N_O2_A19_seed",  
                "SUM-159_NLS_2N_O1_A19_seed",   "SUM-159_NLS_2N_MRCA_harvest") 

karyotypes <- get_karyotyping(cloneIds)

lut <-  sapply(cloneIds,function(ii){
  if(x$event[x$id==ii]=="seeding") return(ii)
  return(x$passaged_from_id1[x$id==ii])
})

names(lut) <- cloneIds
karyotypes$passage_id <- lut[karyotypes$id]

```

Mapping all the data onto cloneID passages:

```{r}


lut_o2 <- m$oxygen_pct
names(lut_o2) <- paste0("x",m$id) 

config <- jsonlite::fromJSON("data/parametersO2.json",  flatten = FALSE, simplifyVector = FALSE)
filters <- config$filters[[1]]$ranges  # Read filter ranges



## -- Process each filter entry
db_ids <- lapply(seq_along(filters), function(i) recover_lineage(filters[[i]], x))
df     <- do.call(rbind, db_ids)

gaps_2N <- fill_lineage_gaps("_2N_",df,x)
gaps_4N <- fill_lineage_gaps("_4N_",df,x)

gaps_df <- rbind(gaps_2N,gaps_4N)
gaps_df$g <- NaN
gaps_df$sublabel_value <- "linker"
gaps_df$adjPass <- NaN
lineage_df <- rbind(df[,c("id","passaged_from_id1","passage","adjPass","event","label_value","g","sublabel_value","media")],
                    gaps_df[,c("id","passaged_from_id1","passage","adjPass","event","label_value","g","sublabel_value","media")])

lineage_df$imaged <- lineage_df$id%in%df$id
lineage_df$karyotyped <- lineage_df$id%in%cloneIds
lineage_df$passage_id <- lineage_df$id
lineage_df$passage_id[lineage_df$event=="harvest"] <- lineage_df$passaged_from_id1[lineage_df$event=="harvest"]
lut1 <- lineage_df$passage_id
names(lut1) <- lineage_df$id
lineage_df$passage_from <- lut1[lineage_df$passaged_from_id1]

tmp <- split(lineage_df,f=lineage_df$passage_id)
lineage_df <- do.call(rbind,lapply(tmp,function(ti){
  imaged <- sum(ti$imaged)>0
  karyotyped <- sum(ti$karyotyped)>0
  if(nrow(ti)>1) ti <- ti[ti$event=="seeding",]
  ti$imaged <- imaged
  ti$karyotyped <- karyotyped
  ti
}))

ff <- list.files("data/flow/Hypoxia_SUM159/")
ff <- ff[!grepl("Control",ff)] ## no passage ID for controls.
fmap <- gsub("Sample_","",ff)
fmap <- gsub("SUM159","SUM-159_NLS",fmap)
fmap <- gsub(".fcs","",fmap)

has_flow <- do.call(cbind,lapply(fmap,function(fi) grepl(fi,lineage_df$passage_id)))
has_flow <- rowSums(has_flow)>0

print(paste("matched",sum(has_flow),"passages, expected:",length(ff)))

lineage_df$has_flow <- has_flow
lineage_df$oxygen <- lut_o2[paste0("x",lineage_df$media)]

```




```{r}
p2N <- experiment_lineage_plot(lineage_df[lineage_df$label_value=="2N",])
p4N <- experiment_lineage_plot(lineage_df[lineage_df$label_value=="4N",])
p2N
p4N
```






```{r}
library(flowCore)
library(tidyverse)

path <- "data/flow/Hypoxia_SUM159/"
ff <- list.files(path)

# Define naming map
fmap <- gsub("Sample_", "", ff)
fmap <- gsub("SUM159", "SUM-159_NLS", fmap)
fmap <- gsub(".fcs", "", fmap)
names(fmap) <- ff

# Global binning parameters
n_bins <- 512
max_fluo <- 250000 # Adjust this based on your observed max DNA signal

binned_list <- lapply(ff, function(fi) {
  message(paste("Processing:", fmap[fi]))
  
  # Load and convert
  fcs <- read.FCS(file.path(path, fi))
  dfi <- as.data.frame(exprs(fcs))
  colnames(dfi) <- make.names(colnames(dfi))
  
  # 1. Clean (Trash + Doublets)
  dfi <- dfi[dfi$X450.Violet.C.A > 25000 & dfi$X450.Violet.C.A < max_fluo, ]
  ratio <- dfi$X450.Violet.C.A / dfi$X450.Violet.C.H
  dfi <- dfi[ratio > (median(ratio) - 2*sd(ratio)) & 
             ratio < (median(ratio) + 2*sd(ratio)), ]
  
  # 2. Bin Data
  # Create a sequence of breaks for the histogram
  breaks <- seq(0, max_fluo, length.out = n_bins + 1)
  counts <- hist(dfi$X450.Violet.C.A, breaks = breaks, plot = FALSE)$counts
  bin_mids <- (breaks[-1] + breaks[-length(breaks)]) / 2
  
  # Return binned representation
  data.frame(
    dna_channel = bin_mids,
    count = counts,
    density = counts / sum(counts)
  )
})

# Name the list by your fmap IDs
names(binned_list) <- fmap

# --- Verification ---
# You can quickly look at one sample:
# plot(binned_list[[1]]$dna_channel, binned_list[[1]]$density, type="l")

# Or plot all to check scaling
bind_rows(binned_list, .id = "id") %>%
  ggplot(aes(x = dna_channel, y = density)) +
  facet_wrap(~id, scales = "free_y") +
  geom_line(color = "firebrick") +
  theme_minimal() +
  labs(x = "DNA Content (Binned Area)", y = "Relative Frequency")

```

```{r}
reassign_karyotyping <- function(passageid,g){
  if(!is.na(g$g[g$passage_id==passageid])) return(passageid)
  passagefrom <- g$passage_from[g$passage_id==passageid]
  while(sum(g$passage_from==passagefrom & !is.na(g$passage_from))<2 & passageid!=passagefrom){
    passageid <- passagefrom
    passagefrom <- g$passage_id[g$passage_id==passagefrom]
  }
  return(passagefrom)
}

g <- lineage_df

karyotyped_ids <- g$passage_id[g$karyotyped]
names(karyotyped_ids) <- sapply(karyotyped_ids,reassign_karyotyping,g=g)

g$karyotyped <- g$passage_id%in%names(karyotyped_ids)


fit_data <- lapply(1:nrow(g),function(i){
  gr <- g$g[i]
  flow <- NULL
  if(g$has_flow[i]){
    ix <- which(sapply(names(binned_list),function(j) grepl(j,g$passage_id[i])))
    flow <- binned_list[[ix]]
  } 
  kary <- NULL
  if(g$karyotyped[i]){
    mapped_id <- karyotyped_ids[g$passage_id[i]]
    samples <- do.call(rbind,karyotypes$karyotype[karyotypes$passage_id==mapped_id])
    kary <- rowMeans(samples)
  }
  
  list(g=gr,flow=flow,kary=kary)
})

names(fit_data) <- g$passage_id
saveRDS(fit_data,"data/fit_objects/fit_data.Rds")
```


How to use this sim_jobs table:

Iterate through sim_jobs row by row (they are sorted by depth).

Load the saved state corresponding to parent_key (if NA, start from scratch).

Run the simulation for the specified oxygen.

Save the resulting state to a file named after sim_key.

```{r}

get_sim_jobs <- function(df, ploidy) {
  g <- df[df$label_value == ploidy, c("passage_id", "passage_from", "oxygen")]
  parents <- setNames(g$passage_from, g$passage_id)
  oxygens <- setNames(g$oxygen, g$passage_id)

  get_history <- function(id) {
    pid <- parents[id]
    # Stop if parent is NA (true root) or not in current subset (new sub-root)
    if (is.na(pid) || !pid %in% names(parents)) return(as.character(oxygens[id]))
    paste(get_history(pid), oxygens[id], sep = "_")
  }

  g$sim_key    <- sapply(g$passage_id, get_history)
  g$parent_key <- g$sim_key[match(g$passage_from, g$passage_id)]

  # Unique transitions
  sim_jobs <- unique(g[, c("parent_key", "oxygen", "sim_key")])
  
  # Organize
  sim_jobs$depth    <- stringr::str_count(sim_jobs$sim_key, "_")
  sim_jobs          <- sim_jobs[order(sim_jobs$depth), ]
  sim_jobs$data_ids <- split(g$passage_id, g$sim_key)[sim_jobs$sim_key]
  
  rownames(sim_jobs) <- NULL
  return(sim_jobs)
}

# Generate jobs
jobs_2N <- get_sim_jobs(lineage_df, "2N")
saveRDS(jobs_2N,"data/fit_objects/jobs_2N.Rds")
jobs_4N <- get_sim_jobs(lineage_df, "4N")
saveRDS(jobs_4N,"data/fit_objects/jobs_4N.Rds")
```


```{r}


run_sim_jobs_in_memory <- function(theta, sim_jobs, fit_data, parnames,
                                   start_N = 44L,
                                   grid = list(N_min = 22L, N_max = 200L, N_unit = 22L),
                                   stop_at = list(time = 60, size = 64),
                                   sd_g = 0.15,
                                   keep_states = FALSE,
                                   eps = 1e-16) {
  
  # --- Likelihood Helpers ---
  ll_g <- function(g_obs, g_model, sd_g) {
    if (is.null(g_obs) || length(g_obs) == 0L) return(0)
    if (!is.finite(g_obs)) return(0)
    dnorm(g_obs, mean = g_model, sd = sd_g, log = TRUE)
  }
  
  ll_kary <- function(kary_obs, dist_df, N_unit, eps) {
    if (is.null(kary_obs) || length(kary_obs) == 0L) return(0)
    kary_obs <- kary_obs[is.finite(kary_obs)]
    if (!length(kary_obs)) return(0)
    
    p_by_N <- dist_df$fraction
    names(p_by_N) <- as.character(dist_df$N)
    
    N_hat <- as.integer(round(kary_obs * N_unit))
    N_hat <- pmax(min(dist_df$N), pmin(max(dist_df$N), N_hat)) # clamp
    sum(log(p_by_N[as.character(N_hat)] + eps))
  }
  
  ll_flow <- function(flow_obs, model_res) 0
  
  ll_one_id <- function(dat, model_res) {
    ll_g(dat$g, model_res$growth_rate, sd_g) +
      ll_flow(dat$flow, model_res) +
      ll_kary(dat$kary, model_res$distribution, grid$N_unit, eps)
  }
  
  # --- 1. Parameter Transformation ---
  theta_vals <- exp(theta)
  theta_list <- as.list(theta_vals)
  names(theta_list) <- parnames
  
  # --- 2. PRE-CALCULATION CACHE ---
  # Identify all unique oxygen levels in the job list
  unique_O <- unique(sim_jobs$oxygen)
  system_cache <- vector("list", length(unique_O))
  names(system_cache) <- as.character(unique_O)
  
  # Loop once per unique condition to build Q matrices
  for(o_lvl in unique_O) {
    # Build Physics
    sys <- build_transition_matrix(o_lvl, theta_list, grid)
    
    # Pre-calculate Rate Matrix Q = lambda * (B - I)
    I_mat <- diag(nrow(sys$B))
    Q_mat <- sys$lambda * (sys$B - I_mat)
    
    # Store minimal needed data for run_ploidy_model
    system_cache[[as.character(o_lvl)]] <- list(
      Q = Q_mat,
      grid = sys$grid,
      lambda = sys$lambda,
      B = sys$B # Keep B if we ever need to fallback to desolve
    )
  }
  
  # --- 3. Simulation Loop ---
  states <- if (keep_states) vector("list", nrow(sim_jobs)) else NULL
  if (keep_states) names(states) <- sim_jobs$sim_key
  
  ll_by_job <- numeric(nrow(sim_jobs))
  names(ll_by_job) <- sim_jobs$sim_key
  ll_total <- 0
  
  # Cache only u_vec for parents when not keeping full states
  u_cache <- if (!keep_states) vector("list", nrow(sim_jobs)) else NULL
  if (!keep_states) names(u_cache) <- sim_jobs$sim_key
  
  for (i in seq_len(nrow(sim_jobs))) {
    job <- sim_jobs[i, ]
    sim_key    <- job$sim_key
    parent_key <- job$parent_key
    O          <- job$oxygen
    
    # Retrieve Pre-built System
    cached_sys <- system_cache[[as.character(O)]]
    
    start_u <- NULL
    if (!is.na(parent_key)) {
      if (keep_states) {
        if (is.null(states[[parent_key]])) stop("Parent state not available: ", parent_key)
        start_u <- states[[parent_key]]$u_vec
      } else {
        if (is.null(u_cache[[parent_key]])) stop("Parent state not available: ", parent_key)
        start_u <- u_cache[[parent_key]]
      }
    }
    
    # Pass 'cached_sys' to skip rebuilding matrix
res <- tryCatch({
      run_ploidy_model(
        O = O, theta = theta_list,
        start_N = start_N,
        start_u = start_u,
        grid = grid,
        stop_at = stop_at,
        method = "expm",
        cached_system = cached_sys
      )
    }, error = function(e) {
      # Optional: Print error to see what happened (uncomment if debugging)
      # message(sprintf("Job %s failed: %s", sim_key, e$message))
      return(NULL) # Sentinel for failure
    })

    # If simulation crashed, abort immediately and return huge penalty
    if (is.null(res)) {
      return(1e12) # Large positive value (since we minimize negative LL)
    }
    
    # Score Data
    ids <- job$data_ids[[1]]
    ll_i <- 0
    for (pid in ids) {
      dat <- fit_data[[pid]]
      ll_i <- ll_i + ll_one_id(dat, res)
    }
    
    ll_by_job[i] <- ll_i
    ll_total <- ll_total + ll_i
    
    if (keep_states) {
      states[[sim_key]] <- res
    } else {
      u_cache[[sim_key]] <- res$u_vec
    }
  }
  
  out <- -ll_total
  
  # Optional: Print for monitoring
   print(unlist(theta_list))
   print(out)
  
  if (keep_states) {
    out <- list(ll = ll_total, ll_by_job = ll_by_job)
    attr(states, "data_ids") <- setNames(sim_jobs$data_ids, sim_jobs$sim_key)
    out$states <- states
  }
  out
}


source("models/buffering.R")

theta <- list(
  p_misseg = 0.003,
  p_wgd    = 1e-4,
  beta     = 0.8,
  n_exp    = 2,
  smax     = 0.9,
  k_o      = 2.5,
  lam_max  = log(2)/1,
  lam_min = 0.1# ~0.6931 / day  (≈1-day doubling)
)


fit_data <- readRDS("data/fit_objects/fit_data.Rds")
jobs_2N <- readRDS("data/fit_objects/jobs_2N.Rds")
#states_2N <- run_sim_jobs_in_memory(theta, jobs_2N, fit_data = fit_data)

res <- optim(log(unlist(theta)),run_sim_jobs_in_memory,sim_jobs=jobs_2N, fit_data = fit_data,parnames=names(theta))


```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# ============================================================
# 1. HELPERS & BUILDER
# ============================================================

make_passage_map <- function(sim_jobs) {
  # Expand list-column 'data_ids' so we have one row per observation
  do.call(rbind, lapply(seq_len(nrow(sim_jobs)), function(i){
    data.frame(
      sim_key    = sim_jobs$sim_key[i],
      parent_key = sim_jobs$parent_key[i],
      oxygen     = sim_jobs$oxygen[i],
      depth      = sim_jobs$depth[i],
      passage_id = sim_jobs$data_ids[[i]], 
      stringsAsFactors = FALSE
    )
  }))
}

build_fit_viz_data <- function(states, sim_jobs, fit_data, N_unit = 22L) {
  
  # --- A. Merge Metadata with Model Results ---
  pm <- make_passage_map(sim_jobs)
  
  # Extract predicted growth rates
  pred_g_df <- data.frame(
    sim_key = names(states),
    pred_g  = sapply(states, function(x) if(is.null(x)) NA_real_ else x$growth_rate),
    stringsAsFactors = FALSE
  )
  
  # Master Dataframe for Growth Plot
  # Note: This may have multiple rows per sim_key (one per data point)
  growth_df <- pm %>% 
    left_join(pred_g_df, by = "sim_key") %>%
    mutate(passage_idx = depth) 
  
  # Attach Observed Growth
  growth_df$obs_g <- sapply(growth_df$passage_id, function(pid) {
    val <- fit_data[[pid]]$g
    if (is.null(val) || length(val) == 0 || !is.finite(val)) return(NA_real_)
    as.numeric(val)
  })
  
  # --- B. Process Ploidy Distributions ---
  
  # 1. Extract Observed Data 
  obs_ploidy_list <- lapply(growth_df$passage_id, function(pid) {
    k <- fit_data[[pid]]$kary
    if (is.null(k)) return(NULL)
    k <- k[is.finite(k)]
    if (length(k) == 0) return(NULL)
    
    # Bin observed data
    kb <- round(k * N_unit) / N_unit
    tab <- as.data.frame(table(kb), stringsAsFactors = FALSE)
    colnames(tab) <- c("kary_bin", "n")
    
    data.frame(
      passage_id = pid,
      kary_bin   = as.numeric(as.character(tab$kary_bin)),
      obs_frac   = tab$n / sum(tab$n),
      stringsAsFactors = FALSE
    )
  })
  obs_ploidy <- do.call(rbind, obs_ploidy_list)
  
  # 2. Extract Predicted Data (Only for IDs present in Obs)
  if (!is.null(obs_ploidy)) {
    ids_with_data <- unique(obs_ploidy$passage_id)
    
    pred_ploidy_list <- lapply(seq_len(nrow(growth_df)), function(i) {
      pid <- growth_df$passage_id[i]
      if (!pid %in% ids_with_data) return(NULL) 
      
      key <- growth_df$sim_key[i]
      if (is.null(states[[key]])) return(NULL)
      
      dist <- states[[key]]$distribution
      
      data.frame(
        passage_id = pid,
        oxygen     = growth_df$oxygen[i],
        depth      = growth_df$depth[i],
        kary_bin   = dist$N / N_unit,
        pred_frac  = dist$fraction,
        stringsAsFactors = FALSE
      )
    })
    pred_ploidy <- do.call(rbind, pred_ploidy_list)
  } else {
    pred_ploidy <- NULL
  }
  
  list(
    growth = growth_df, 
    obs_ploidy = obs_ploidy, 
    pred_ploidy = pred_ploidy
  )
}

# ============================================================
# 2. PLOTTING FUNCTIONS (FIXED)
# ============================================================

plot_growth_fit <- function(viz_data) {
  df <- viz_data$growth
  
  # --- FIX: Deduplicate Simulation Topology ---
  # We need unique nodes to draw the lines correctly.
  # Otherwise, if Sim A has 2 data points, we draw multiple lines for it.
  sim_nodes <- df %>% 
    distinct(sim_key, .keep_all = TRUE) %>% 
    select(sim_key, parent_key, passage_idx, pred_g, oxygen)
  
  # Build Edges: Join Child Nodes to Parent Nodes
  # This avoids the many-to-many warning
  sim_edges <- sim_nodes %>% 
    inner_join(sim_nodes, by = c("parent_key" = "sim_key"), suffix = c("", "_parent")) %>% 
    filter(!is.na(pred_g), !is.na(pred_g_parent))
  
  # --- Plotting ---
  ggplot() +
    # 1. Trajectories (Segments): Use unique edges
    geom_segment(data = sim_edges, 
                 aes(x = passage_idx_parent, y = pred_g_parent, 
                     xend = passage_idx, yend = pred_g,
                     color = factor(oxygen)), 
                 alpha = 0.6, linewidth = 0.8) +
    
    # 2. Model Points: Use unique nodes
    geom_point(data = sim_nodes, 
               aes(x = passage_idx, y = pred_g, 
                   color = factor(oxygen), shape = "Model"), 
               size = 2) +
    
    # 3. Observed Points: Use full dataframe (filter NAs to silence warnings)
    geom_point(data = df %>% filter(!is.na(obs_g)), 
               aes(x = passage_idx, y = obs_g, 
                   color = factor(oxygen), shape = "Observed"), 
               size = 3, alpha = 0.8) +
    
    # Aesthetics
    scale_color_viridis_d(name = "Oxygen (%)", option = "C", end = 0.9) +
    scale_shape_manual(name = "Data Source", values = c("Model" = 16, "Observed" = 4)) +
    
    labs(title = "Growth Rate Trajectories",
         subtitle = "Lines connect Model Parent -> Child",
         x = "Passage Index (Depth)", 
         y = "Growth Rate (1/day)") +
    
    theme_bw() +
    theme(legend.position = "bottom")
}

plot_ploidy_fit <- function(viz_data) {
  obs <- viz_data$obs_ploidy
  pred <- viz_data$pred_ploidy
  
  if (is.null(obs) || nrow(obs) == 0) {
    return(ggplot() + theme_void() + labs(title = "No Karyotype Data to Plot"))
  }
  
  # Clean Facet Labels
  meta <- viz_data$growth %>% 
    select(passage_id, oxygen, depth) %>% 
    distinct()
  
  obs <- obs %>% left_join(meta, by = "passage_id")
  obs$label <- paste0("O2: ", obs$oxygen, "% | P", obs$depth, "\n(", obs$passage_id, ")")
  
  pred <- pred %>% 
    left_join(obs %>% select(passage_id, label) %>% distinct(), by = "passage_id")

  ggplot() +
    # Observed (Bars)
    geom_col(data = obs, aes(x = kary_bin, y = obs_frac, fill = "Observed"), 
             alpha = 0.5, width = 0.08, position = "identity") +
    # Predicted (Line)
    geom_line(data = pred, aes(x = kary_bin, y = pred_frac, color = "Model"), 
              linewidth = 1) +
    
    facet_wrap(~label, scales = "free_y") +
    
    scale_fill_manual(name = "", values = c("Observed" = "black")) +
    scale_color_manual(name = "", values = c("Model" = "firebrick")) +
    
    labs(title = "Ploidy Distribution Fits",
         x = "Ploidy (N / Haploid)", 
         y = "Fraction") +
    theme_bw() +
    theme(strip.background = element_rect(fill = "#f0f0f0"))
}

theta <- list(
  p_misseg = 2.369194e-02,
  p_wgd    = 9.824223e-02,
  beta     = 8.800753e-07,
  n_exp    = 3.634542e+00,
  smax     = 6.719432e-01,
  k_o      = 1.119845e+02,
  lam_max  = 3.334866e+00,
  lam_min = 1.345119e-04# ~0.6931 / day  (≈1-day doubling)
)


 out <- run_sim_jobs_in_memory(log(unlist(theta)), jobs_2N, fit_data, keep_states=TRUE,parnames=names(theta))
 states <- out$states

# 2) build viz data
 viz <- build_fit_viz_data(states, jobs_2N, fit_data, N_unit = 22L)

# 3) plots
 p_ploidy <- plot_ploidy_fit(viz)
 p_growth <- plot_growth_fit(viz)
```



```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# ---- helper: make per-passage mapping ----
make_passage_map <- function(sim_jobs) {
  # sim_jobs has list-column data_ids; expand to one row per passage_id
  do.call(rbind, lapply(seq_len(nrow(sim_jobs)), function(i){
    data.frame(
      sim_key = sim_jobs$sim_key[i],
      parent_key = sim_jobs$parent_key[i],
      oxygen = sim_jobs$oxygen[i],
      depth = sim_jobs$depth[i],
      passage_id = sim_jobs$data_ids[[i]],
      stringsAsFactors = FALSE
    )
  }))
}

# ---- helper: bin observed kary to model grid bins ----
bin_kary_to_grid <- function(kary, N_unit) round(kary * N_unit) / N_unit

# ---- build plotting data from states + fit_data ----
build_fit_viz_data <- function(states, sim_jobs, fit_data, N_unit = 22L) {
  pm <- make_passage_map(sim_jobs)

  # predicted growth per sim_key
  pred_g <- data.frame(
    sim_key = names(states),
    pred_g = sapply(states, `[[`, "growth_rate"),
    stringsAsFactors = FALSE
  )

  pm <- pm %>% left_join(pred_g, by="sim_key") %>%
    mutate(passage_idx = depth + 1L)  # "time" proxy: position in the oxygen-history chain

  # observed growth per passage_id
  pm$obs_g <- sapply(pm$passage_id, function(pid) {
    x <- fit_data[[pid]]$g
    if (is.null(x) || length(x)==0L || !is.finite(x)) NA_real_ else as.numeric(x)
  })

  # predicted ploidy distribution per passage_id (project to kary = N/N_unit)
  pred_ploidy <- do.call(rbind, lapply(seq_len(nrow(pm)), function(i){
    key <- pm$sim_key[i]
    dist <- states[[key]]$distribution
    data.frame(
      passage_id = pm$passage_id[i],
      passage_idx = pm$passage_idx[i],
      sim_key = key,
      kary_bin = dist$N / N_unit,
      pred_frac = dist$fraction,
      stringsAsFactors = FALSE
    )
  }))

  # observed kary per passage_id -> binned -> fraction
  obs_ploidy <- do.call(rbind, lapply(pm$passage_id, function(pid){
    k <- fit_data[[pid]]$kary
    if (is.null(k)) return(NULL)
    k <- k[is.finite(k)]
    if (!length(k)) return(NULL)
    kb <- bin_kary_to_grid(k, N_unit)
    tab <- as.data.frame(table(kb), stringsAsFactors = FALSE)
    colnames(tab) <- c("kary_bin","n")
    tab$kary_bin <- as.numeric(tab$kary_bin)
    tab$obs_frac <- tab$n / sum(tab$n)
    tab$passage_id <- pid
    tab
  }))

  list(pm = pm, pred_ploidy = pred_ploidy, obs_ploidy = obs_ploidy)
}

# ---- plotting ----
plot_ploidy_fit <- function(pred_ploidy, obs_ploidy) {
  # merge on bins; missing bins -> 0
  df <- full_join(pred_ploidy, obs_ploidy, by=c("passage_id","kary_bin")) %>%
    mutate(pred_frac = replace_na(pred_frac, 0),
           obs_frac  = replace_na(obs_frac, 0)) %>%
    distinct(passage_id, kary_bin, .keep_all = TRUE)

  # order facets by passage_idx if present
  if ("passage_idx" %in% names(df)) {
    ord <- df %>%
  group_by(passage_id) %>%
  summarise(passage_idx = first(passage_idx), .groups="drop") %>%
  arrange(passage_idx)

  df$passage_id <- factor(df$passage_id, levels = ord$passage_id)

  }

  ggplot(df, aes(x = kary_bin)) +
    geom_col(aes(y = obs_frac), alpha = 0.35) +
    geom_line(aes(y = pred_frac), linewidth = 0.6) +
    facet_wrap(~ passage_id, scales = "free_y") +
    labs(x = "Ploidy (N / N_unit)", y = "Fraction (observed bars, predicted line)") +
    theme_bw()
}

plot_growth_fit <- function(pm) {
  df <- pm %>% filter(is.finite(obs_g), is.finite(pred_g)) %>%
    arrange(passage_idx)

  ggplot(df, aes(x = passage_idx)) +
    geom_point(aes(y = obs_g)) +
    geom_line(aes(y = pred_g)) +
    labs(x = "Passage index (from sim_key depth)", y = "Growth rate (1/day)") +
    theme_bw()
}

# =========================
# Usage
# =========================



# p_ploidy
# p_growth

```

